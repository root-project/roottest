# The following CMake code does not work on Windows at the moment
if(NOT ROOT_root7_FOUND OR (MSVC AND NOT win_broken_tests))
  return()
endif()

# Generate common dictionary for custom class
ROOTTEST_GENERATE_DICTIONARY(
  ntuple_makeproject_event_dict
  ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header.h
  LINKDEF ${CMAKE_CURRENT_SOURCE_DIR}/ntuple_makeproject_header_LinkDef.h
  # Otherwise TFile::MakeProject will find the dictionary module and will not generate the corresponding class header
  NO_ROOTMAP NO_CXXMODULE
  FIXTURES_SETUP generated_event_dictionary
)

# MakeProject with TTree data
# Write the TTree with the custom class branch
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_write_ttree
  LIBRARIES Core RIO Tree
  DEPENDS ntuple_makeproject_event_dict
  FIXTURES_REQUIRED generated_event_dictionary
  FIXTURES_SETUP write_ttree_executable)
# Specify more than one input source for the generated executable
target_sources(
  ntuple_makeproject_write_ttree
  PRIVATE write_ttree.cxx ntuple_makeproject_event_dict.cxx
)
ROOTTEST_ADD_TEST(write_ttree
                  EXEC ./ntuple_makeproject_write_ttree
                  FIXTURES_REQUIRED write_ttree_executable
                  FIXTURES_SETUP written_ttree)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_makeproject_ttree
  makeproject_ttree.cxx
  LIBRARIES Core RIO Tree
  FIXTURES_SETUP makeproject_ttree)
ROOTTEST_ADD_TEST(makeproject_ttree
                  EXEC ./ntuple_makeproject_makeproject_ttree
                  FIXTURES_REQUIRED "written_ttree;makeproject_ttree"
                  FIXTURES_SETUP makeproject_ttree_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_read_ttree
  read_ttree.cxx
  LIBRARIES ${ROOT_LIBRARIES} gtest gtest_main gmock gmock_main ttreestltest
  FIXTURES_REQUIRED makeproject_ttree_called
  FIXTURES_SETUP read_ttree_executable
)
target_include_directories(ntuple_makeproject_read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ${GTEST_INCLUDE_DIR})
target_link_directories(ntuple_makeproject_read_ttree PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/libttreestltest)
# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/libttreestltest")
ROOTTEST_ADD_TEST(read_ttree
                  EXEC ./ntuple_makeproject_read_ttree
		  FIXTURES_REQUIRED "read_ttree_executable")
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})

# MakeProject with RNTuple data
# Write the RNTuple with the custom class field
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_write_rntuple
  LIBRARIES Core RIO ROOTNTuple
  DEPENDS ntuple_makeproject_event_dict
  FIXTURES_REQUIRED generated_event_dictionary
  FIXTURES_SETUP write_rntuple_executable)
# Specify more than one input source for the generated executable
target_sources(
  ntuple_makeproject_write_rntuple
  PRIVATE write_rntuple.cxx ntuple_makeproject_event_dict.cxx
)
# Do not interfere with the compilation of the corresponding executable for the TTree test
set_tests_properties(
  roottest-root-ntuple-ntuple-makeproject-ntuple_makeproject_write_rntuple-build
  PROPERTIES DEPENDS roottest-root-ntuple-ntuple-makeproject-ntuple_makeproject_write_ttree-build
)
ROOTTEST_ADD_TEST(write_rntuple
                  EXEC ./ntuple_makeproject_write_rntuple
                  FIXTURES_REQUIRED write_rntuple_executable
                  FIXTURES_SETUP written_rntuple)

# Call MakeProject on the output file
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_makeproject_rntuple
  makeproject_rntuple.cxx
  LIBRARIES Core RIO ROOTNTuple
  FIXTURES_SETUP makeproject_rntuple)
ROOTTEST_ADD_TEST(makeproject_rntuple
                  EXEC ./ntuple_makeproject_makeproject_rntuple
                  FIXTURES_REQUIRED "written_rntuple;makeproject_rntuple"
                  FIXTURES_SETUP makeproject_rntuple_called)

# Read back the class instance thanks to the shared library generated by MakeProject.
# Make sure it corresponds to the data stored in the original custom class
ROOTTEST_GENERATE_EXECUTABLE(
  ntuple_makeproject_read_rntuple
  read_rntuple.cxx
  LIBRARIES ${ROOT_LIBRARIES} gtest gtest_main gmock gmock_main rntuplestltest ROOTNTuple
  FIXTURES_REQUIRED makeproject_rntuple_called
  FIXTURES_SETUP read_rntuple_executable
)
target_include_directories(ntuple_makeproject_read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ${GTEST_INCLUDE_DIR})
target_link_directories(ntuple_makeproject_read_rntuple PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest)
# Need to also explicitly set the LD_LIBRARY_PATH (at least on MacOS), so that
# the generated library with the custom class can be loaded by the read test.
# Setting the value of ${ld_library_path} in the ENVIRONMENT argument of the
# ROOTTEST_ADD_TEST function will not work, because that function sets the same
# variable internally, thus overriding our choice. The simplest thing to do is
# to append our directory to the ${ROOTTEST_ENV_LIBRARYPATH} contents, which
# are automatically used by ROOTTEST_ADD_TEST
set(_roottest_env_librarypath ${ROOTTEST_ENV_LIBRARYPATH})
set(ROOTTEST_ENV_LIBRARYPATH "${ROOTTEST_ENV_LIBRARYPATH}:${CMAKE_CURRENT_BINARY_DIR}/librntuplestltest")
ROOTTEST_ADD_TEST(read_rntuple
                  EXEC ./ntuple_makeproject_read_rntuple
                  FIXTURES_REQUIRED "read_rntuple_executable")
set(ROOTTEST_ENV_LIBRARYPATH ${_roottest_env_librarypath})

